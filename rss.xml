<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Matthew Brown's JS Blog]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://github.com/mbrown333/mbrown333.github.io</link><generator>RSS for Node</generator><lastBuildDate>Fri, 08 Jun 2018 21:21:03 GMT</lastBuildDate><item><title><![CDATA[A New Beginning...]]></title><description><![CDATA[New Blog! If you’ve checked out my blog before you’ll likely notice things look pretty different.  I’m currently in the middle of the…]]></description><link>https://github.com/mbrown333/mbrown333.github.io/20180608-a-new-beginning/</link><guid isPermaLink="false">https://github.com/mbrown333/mbrown333.github.io/20180608-a-new-beginning/</guid><pubDate>Fri, 08 Jun 2018 15:31:00 GMT</pubDate><content:encoded>&lt;h2&gt;New Blog!&lt;/h2&gt;
&lt;p&gt;If you’ve checked out my blog before you’ll likely notice things look pretty different.  I’m currently in the middle of the process of re-platforming my blog away from Wordpress and now will be using Gatsby.  I’ve started the process of porting over my previous posts and will continue to do so until everything has been moved over.&lt;/p&gt;
&lt;h2&gt;Why Gatsby?&lt;/h2&gt;
&lt;p&gt;Good question.&lt;/p&gt;
&lt;p&gt;If you haven’t heard of &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt; yet it’s a static site generator that uses React.js.  The main reason I switched to Gatsby is that it is blazing fast.  And it is very easy to use &lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt; to deploy a Gatsby site to Github pages.  So another win is that hosting will be free.  Not that it was a lot before, but free beats cheap in my book.&lt;/p&gt;
&lt;p&gt;If you are interested in learning to do this yourself &lt;a href=&quot;https://medium.freecodecamp.org/how-to-write-a-blog-using-gatsby-from-your-phone-e92a99851a04&quot;&gt;I recommend you check out this article for details on how&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Stay Tuned&lt;/h2&gt;
&lt;p&gt;One of the reasons I’m excited about this move is it makes it much easier for me to deliver new content as I can focus less on administration and more on creating content.  So keep an eye out for more coming soon!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Functional Stateless Components in React]]></title><description><![CDATA[In this article I’m going to explain functional stateless React components using simple code examples. Now this may sound abstract, but the…]]></description><link>https://github.com/mbrown333/mbrown333.github.io/20180409-functional-stateless-components-in-react/</link><guid isPermaLink="false">https://github.com/mbrown333/mbrown333.github.io/20180409-functional-stateless-components-in-react/</guid><pubDate>Mon, 09 Apr 2018 22:02:52 GMT</pubDate><content:encoded>&lt;p&gt;In this article I’m going to explain functional stateless React components using simple code examples. Now this may sound abstract, but the idea behind this is very simple. The idea is that functional stateless components are just displaying data that is passed to them through props. That is it. No state, no methods, just plugging data into a template and returning a component to render.&lt;/p&gt;
&lt;p&gt;When you see components in React they are normally declared in one of two ways. The first extends &lt;code class=&quot;language-text&quot;&gt;React.Component&lt;/code&gt;. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class FancyComponent extends React.Component { 
    constructor(props) { 
      super(props); 
    } 
    ...
}&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;The example uses ES6 class notation to extend &lt;code class=&quot;language-text&quot;&gt;React.Component&lt;/code&gt;. You use this method when you are creating a component that does one of the following: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uses state&lt;/li&gt;
&lt;li&gt;Uses a life cycle method (i.e. &lt;em&gt;componentDidMount&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In all likelihood you will be using the class approach for your container Components that hold a fair amount of logic and are composed of presentational components. For the lower level building blocks you can simply declare a function that returns the component that you want to display like the following example. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function NotSoFancyComponent(props) { 
  const { name, city, } = props; 
  return &amp;lt;div&amp;gt;Hello, {name} from {city}!&amp;lt;/div&amp;gt; 
} &lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;In the &lt;code class=&quot;language-text&quot;&gt;NotSoFancyComponent&lt;/code&gt; we deconstruct the &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; object into the &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;city&lt;/code&gt; constants. &lt;em&gt;(You don’t have to do it this way. It is perfectly fine to use {props.name} that is just my preference.)&lt;/em&gt; This is an example of a functional stateless component. No state, no life cycle methods required. Just taking in data as props and plugging it into a component. &lt;/p&gt;
&lt;p&gt;We would use the component as follows. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;NotSoFancyComponent name=&amp;quot;Bob&amp;quot; city=&amp;quot;Kansas City&amp;quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;We can also make this declaration more succinct using an ES6 arrow function. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const NotSoFancyComponent = (props) =&amp;gt; &amp;lt;div&amp;gt;Hello, {props.name} from {props.city}!&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;The nice thing about keeping these components very simple is they can easily be re-used across your application or possibly multiple applications in a component library and you can be assured that they will display the same behavior everywhere. Cleaner code and better performance are two additional benefits to using this approach. &lt;/p&gt;
&lt;p&gt;And if you happen to come to a point where you need to use state or a life cycle method it is very easy to refactor these functions to do so. Let’s say we want to leverage the &lt;code class=&quot;language-text&quot;&gt;componentDidMount&lt;/code&gt; life cycle hook with our example. This is the code changes we would need to make to make it work. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class NotSoFancyComponent extends React.Component { 
  constructor(props) { 
    super(props); 
  } 
  
  componentDidMount() { 
    console.log(&amp;#39;NotSoFancyComponent did mount!&amp;#39;); 
  } 
  
  render() { 
    const { name, city, } = this.props; return &amp;lt;div&amp;gt;Hello, {name} from {city}!&amp;lt;/div&amp;gt; 
  } 
}&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;No drastic changes required. The declaration changes to a class extending &lt;code class=&quot;language-text&quot;&gt;React.Component&lt;/code&gt; and then move the function into the render function. &lt;/p&gt;
&lt;p&gt;I hope this enhances your understanding of functional stateless components as it is a foundational concept for building applications in React.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript's call, bind, and apply - A Quick Explanation]]></title><description><![CDATA[If you don’t use JavaScript’s call, bind, and apply regularly you might not be aware of what they do and how to use these native functions…]]></description><link>https://github.com/mbrown333/mbrown333.github.io/20180409-javascripts-call-bind-and-apply-a-quick-explanation/</link><guid isPermaLink="false">https://github.com/mbrown333/mbrown333.github.io/20180409-javascripts-call-bind-and-apply-a-quick-explanation/</guid><pubDate>Mon, 09 Apr 2018 03:20:04 GMT</pubDate><content:encoded>&lt;p&gt;If you don’t use JavaScript’s call, bind, and apply regularly you might not be aware of what they do and how to use these native functions. I can remember for the longest time being aware they existed, but not really understanding what they were exactly. Having a good grasp on how these work will give you a deeper understanding of the JavaScript language. And if nothing else these functions tend to be a popular subject of JavaScript interview questions so being aware of how they work can still help you out even if you don’t use them regularly. &lt;/p&gt;
&lt;p&gt;Bind, call, and apply are all part of the prototype object for all JavaScript functions. The reason these calls can come in handy is JavaScript’s &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;. Let’s take a look at some code. When you’re calling an object’s function and the object is the left of the dot as below then that object will be &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; when the &lt;code class=&quot;language-text&quot;&gt;printPerson&lt;/code&gt; function is called. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(function() { 
  const person = { 
    age: 21, 
    name: &amp;#39;Bob&amp;#39;, 
    printPerson() { 
      console.log(`${this.name} is ${this.age}`); 
      } 
    }; 

    person.printPerson(); // Bob is 21 
})(); &lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;This works fine if you’re working with objects in an object oriented fashion where data and functionality are grouped together in the object. If you’re using a functional approach then this changes things. If we move the &lt;code class=&quot;language-text&quot;&gt;printPerson&lt;/code&gt; function out of the &lt;code class=&quot;language-text&quot;&gt;person&lt;/code&gt; object and declare it as a function elsewhere then we’ve lost the ability to use &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; in the function. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(function() { 
  const person = { 
    age: 21, 
    name: &amp;#39;Bob&amp;#39;, 
  }; 
  
  function printPerson() { 
    console.log(`${this.name} is ${this.age}`); 
  } 
  
  printPerson(); // FAILS! 
})();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;We could change the function to pass in person as a parameter or we can use &lt;code class=&quot;language-text&quot;&gt;call&lt;/code&gt; to specify to the function what the &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; context should be. &lt;/p&gt;
&lt;p&gt;[code] (function() { const person = { age: 21, name: ‘Bob’, }; function printPerson() { console.log(&lt;code class=&quot;language-text&quot;&gt;${this.name} is ${this.age}&lt;/code&gt;); } printPerson.call(person); // Bob is 21 })(); [/code] &lt;/p&gt;
&lt;p&gt;And voila, we passed in the &lt;code class=&quot;language-text&quot;&gt;person&lt;/code&gt; object and our &lt;code class=&quot;language-text&quot;&gt;printPerson&lt;/code&gt; function now knows to use this object as the &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; context. You can also pass parameters in addition to the context with call as below. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(function() { 
  const person = { 
    age: 21, 
    name: &amp;#39;Bob&amp;#39;, 
  };

  function printPerson(city, state) { 
    console.log(`${this.name} is ${this.age} from ${city}, ${state}`); 
  }

  printPerson.call(person, &amp;#39;Chicago&amp;#39;, &amp;#39;IL&amp;#39;); // Bob is 21 from Chicago, IL 
})();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;This is the same thing as before just demonstrating that any number of parameters can be passed in after the context. The context is always the first parameter and then all others follow after.&lt;/p&gt;
&lt;p&gt;That’s the basic idea with call, now what about bind?&lt;/p&gt;
&lt;p&gt;Bind is actually pretty much the same as call except the function won’t be invoked immediately. It’s just a way to defer execution until later. If you’ve used React this will look familiar to you as bind is often used to bind functions to React Components.&lt;/p&gt;
&lt;p&gt;Let’s update our code example to use bind this time. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(function() { 
  const person = { 
    age: 21, 
    name: &amp;#39;Bob&amp;#39;, 
  }; 
  const printPersonDeferred = printPerson.bind(person); 
  
  function printPerson() { 
    console.log(`${this.name} is ${this.age}`); 
  } 
  
  printPersonDeferred(); // Bob is 21 
})();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;And then expand on this to demonstrate parameters. This time we pass the parameters in when we make the deferred execution call rather than at the time bind is called. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(function() { 
  const person = { age: 21, name: &amp;#39;Bob&amp;#39;, }; 
  
  const printPersonDeferred = printPerson.bind(person); 
  
  function printPerson(city, state) { 
    console.log(`${this.name} is ${this.age} from ${city}, ${state}`); 
  } 
  
  printPersonDeferred(&amp;#39;Chicago&amp;#39;, &amp;#39;IL&amp;#39;); // Bob is 21 from Chicago, IL 
})();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;All right we have bind and call down. Let’s move on to apply. Apply is practically the same as call except apply requires you to pass in your parameters after the this context as an array. This is how we would need to modify our code to use apply below. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(function() { 
  const person = { age: 21, name: &amp;#39;Bob&amp;#39;, }; 
  
  function printPerson(city, state) { 
    console.log(`${this.name} is ${this.age} from ${city}, ${state}`); 
  } 
  
  printPerson.apply(person, [&amp;#39;Chicago&amp;#39;, &amp;#39;IL&amp;#39;]); // Bob is 21 from Chicago, IL 
})();&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;So you see when you use apply JavaScript unpacks your arguments array into the parameter variables of the function you are calling with apply.&lt;/p&gt;</content:encoded></item></channel></rss>