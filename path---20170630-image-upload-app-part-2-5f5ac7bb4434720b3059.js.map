{"version":3,"sources":["webpack:///path---20170630-image-upload-app-part-2-5f5ac7bb4434720b3059.js","webpack:///./.cache/json/20170630-image-upload-app-part-2.json"],"names":["webpackJsonp","515","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug","previous","fields","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,0BAAAC,OAAA,kBAA4DC,gBAAmBC,GAAA,yIAAAC,KAAA,sjYAA8uYC,aAA4CL,MAAA,0FAAAM,KAAA,mBAA2HC,aAAgBC,KAAA,oCAAAC,UAAuDC,QAAUF,KAAA,qCAA2CH,aAAgBL,MAAA,4FAAmGW,MAASD,QAAUF,KAAA,kEAAwEH,aAAgBL,MAAA","file":"path---20170630-image-upload-app-part-2-5f5ac7bb4434720b3059.js","sourcesContent":["webpackJsonp([174222985609962],{\n\n/***/ 515:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Matthew Brown's JS Blog\",\"author\":\"Matthew Brown\"}},\"markdownRemark\":{\"id\":\"/home/travis/build/mbrown333/mbrown333.github.io/src/pages/20170630-image-upload-app-part2/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>Building a Node/Express User service with JWT authentication</h2>\\n<p>In <a href=\\\"/20170630-image-upload-app-part1\\\">Part 1</a> we laid the groundwork for building our web services by setting up Docker containers. </p>\\n<p>Part 2 consist of defining and creating a user table in our PostgreSQL data store and then building a user service that other services and our user interface can talk to. We’ll be using an ORM called knex to handle our database queries. </p>\\n<p><strong>Requirements</strong></p>\\n<ul>\\n<li>Users should be able to register and login</li>\\n<li>We will be using JWT based security to secure our application and the service will be responsible for generating the tokens based on user credentials.</li>\\n<li>Our images service will also communicate with the user service to validate that a user is signed in. If we were creating other services they could also make use of the user service.</li>\\n</ul>\\n<p>In order to follow along with building the service in this article you’ll need to have completed Part 1 or clone the git repository and checkout the Part 2 tag in addition to having Docker installed and running locally: </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">git clone https://github.com/mbrown333/angular4-node-image-upload-app.git \\ncd angular4-node-image-upload-app \\ngit checkout tag/Part2 \\ndocker-compose up</code></pre>\\n      </div>\\n<h2>Database Table Setup</h2>\\n<p>One more thing we’ll need is the knex cli for creating migrations. Use the command <code class=\\\"language-text\\\">npm i -g knex-cli</code> to install. </p>\\n<p>Next step will be to add a knexfile to configure the ORM that we’ll be using to build out our service: </p>\\n<p><em>/users-api/knexfile.js</em> </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">const path = require(&#39;path&#39;); \\n\\nmodule.exports = { \\n  development: { \\n    client: &#39;pg&#39;, \\n    connection: process.env.DATABASE_URL, \\n    migrations: { \\n      directory: path.join(__dirname, &#39;db&#39;, &#39;migrations&#39;) \\n    } \\n  } \\n}</code></pre>\\n      </div>\\n<p>Here we’ve created a config object for our development object. We’re using the ‘pg’ client which is for PostgreSQL. Knex can connect to other types of databases and if you take a look in our package.json file you’ll notice that the pg package is included in the dependencies. </p>\\n<p>For connection we give the environment variable that we specified the database connection string in the docker-compose.yml file. And then finally we specify a directory (/db/migrations) to store migrations in. </p>\\n<p>Now we’re ready to create a migration using the knex-cli. Open up a command prompt in the /users-api folder and enter the following commands: </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">npm install knex knex migrate:make users</code></pre>\\n      </div>\\n<p>This will create a migration file in the /db/migrations folder that has the following structure:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">exports.up = function(knex, Promise) { \\n\\n}; \\n\\nexports.down = function(knex, Promise) { \\n\\n}; </code></pre>\\n      </div>\\n<p>We’ll be putting the changes we want to make in the up function, and a way to reverse those changes in the down function. What we want to accomplish with this migration is to create our user table and define the structure. </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">exports.up = (knex, Promise) =&gt; { \\n  return knex.schema.createTable(&#39;users&#39;, table =&gt; { \\n    table.increments(); \\n    table.timestamp(&#39;createdAt&#39;).notNullable().defaultTo(knex.raw(&#39;now()&#39;)); \\n    table.string(&#39;username&#39;).unique().notNullable(); \\n    table.string(&#39;password&#39;).notNullable(); \\n  }); \\n}; \\n\\nexports.down = function(knex, Promise) { \\n  return knex.schema.dropTable(&#39;users&#39;); \\n};</code></pre>\\n      </div>\\n<p><em>/users-api/db/db.js</em></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">const config = require(&#39;../knexfile.js&#39;); \\nconst knex = require(&#39;knex&#39;)(config[&#39;development&#39;]); \\n\\nmodule.exports = knex; \\n\\nknex.migrate.latest([&#39;development&#39;]);</code></pre>\\n      </div>\\n<p>Pretty straightforward here, we’re just creating a users table to store username and password and an id field. Then in the db.js file we pull our config and knexfile and run the migration we just created. Now that we have our data store defined we’re ready to create our routes. We’ll create a file in the /users-api/routes folder to define our user routes. We’ll be creating three routes to register a user, login a user, and verify a user is authenticated. </p>\\n<p><em>/users-api/routes/users.js</em></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">const express = require(&#39;express&#39;); \\nconst router = express.Router(); \\nconst knex = require(&#39;../db/db&#39;); \\nconst moment = require(&#39;moment&#39;); \\nconst jwt = require(&#39;jwt-simple&#39;); \\nconst bcrypt = require(&#39;bcryptjs&#39;); \\n\\nrouter.post(&#39;/user&#39;, async (req, res) =&gt; { \\n  try { \\n    const salt = bcrypt.genSaltSync(); \\n    const hash = bcrypt.hashSync(req.body.password, salt); \\n    \\n    const user = await knex(&#39;users&#39;) \\n      .insert({ username: req.body.username, password: hash }) \\n      .returning(&#39;*&#39;); \\n      \\n    res.json({ success: true, token: encode(user[0])}); \\n  } catch (err) { \\n    res.status(500).json({ \\n      success: false, \\n      errorMessage: err \\n    }); \\n  } }); \\n  \\n  function encode(user) { \\n    const token = { \\n      exp: moment().add(7, &#39;days&#39;).unix(), \\n      iat: moment().unix(), \\n      sub: user.id \\n    }; \\n    \\n    return jwt.encode(token, process.env.TOKEN_SECRET); \\n  } \\n  \\n  module.exports = router;</code></pre>\\n      </div>\\n<p>This first one is the route for registering a new user. A user will enter a username and password and then use bcrypt to generate a hash and store the hash as a password instead of the plain text version. You’ll see using knex to generate SQL queries is very straightforward. We specify the table ‘users’ and then pass the object to store. </p>\\n<p>Finally the newly created user will be returned so that we can use the jwt-simple module to generate a JWT token to return in the JSON reponse body. Now that users can register they need to have the ability to login. </p>\\n<p><em>/users-api/routes/users.js</em> </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">router.post(&#39;/login&#39;, async (req, res) =&gt; { \\n  try { \\n    const credentials = { \\n      username: req.body.username, \\n      password: req.body.password \\n    }; \\n    \\n    const user = await knex(&#39;users&#39;)\\n      .where({ username: credentials.username })\\n      .first(); \\n      \\n    if (!user || !bcrypt.compareSync(credentials.password, user.password)) { \\n      throw new Error(&#39;Incorrect password&#39;); \\n    } \\n      \\n    res.json({ success: true, token: encode(user) }); \\n  } catch (err) { \\n    res.status(500).json({ status: &#39;error&#39;, message: err }); \\n  } \\n});</code></pre>\\n      </div>\\n<p> We’ll use the username passed in by the user to find a user record in the data store and then let bcrypt test if the entered password matches the hash stored in the database. Then if it does, a token is created and passed back in the response body. </p>\\n<p> <em>/users-api/routes/users.js</em> </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">router.get(&#39;/user&#39;, isAuthenticated, (req, res) =&gt; { \\n  res.json({ status: &#39;success&#39;, user: req.user }) \\n }); \\n  \\n function decode(token, callback) { \\n   const decodedJwt = jwt.decode(token, process.env.TOKEN_SECRET); \\n   const now = moment().unix(); \\n   \\n   if (now &gt; decodedJwt.exp) { \\n     callback(&#39;Token has expired.&#39;); \\n   } else { \\n     callback(null, decodedJwt); \\n   } \\n } \\n \\n function isAuthenticated(req, res, next) { \\n   if (!(req.headers &amp;&amp; req.headers.authorization)) { \\n     return res.status(401).json({ errorMessage: &#39;Unauthorized&#39;} ); \\n   } \\n   \\n   const token = req.headers.authorization; \\n   decode(token, async (err, payload) =&gt; { \\n     try { \\n       if (err) { \\n         return res.status(401).json({ errorMessage: &#39;Token expired&#39;} ); \\n       } \\n       \\n       const user = await knex(&#39;users&#39;).where({ id: parseInt(payload.sub, 10) }).first() \\n       req.user = user.id; \\n       \\n       return next(); \\n     } catch (err) { \\n       res.status(500).json({ errorMessage: err }); \\n     } \\n   }) \\n }</code></pre>\\n      </div>\\n<p>Finally we need a route to verify that a user is logged in and include their id in the response if successful. Using the bcrypt and jwt-simple Node modules to do the heavy lifting you can see that it’s fairly straightforward to create basic JWT authentication for Node services. Putting it all together, here is our final routes file: </p>\\n<p><em>/users-api/routes/users.js</em></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">const express = require(&#39;express&#39;);\\nconst router = express.Router();\\nconst knex = require(&#39;../db/db&#39;);\\nconst moment = require(&#39;moment&#39;);\\nconst jwt = require(&#39;jwt-simple&#39;);\\nconst bcrypt = require(&#39;bcryptjs&#39;);\\n\\nrouter.post(&#39;/user&#39;, async (req, res) =&gt; {\\n    try {\\n        const salt = bcrypt.genSaltSync();\\n        const hash = bcrypt.hashSync(req.body.password, salt);\\n\\n        const user = await knex(&#39;users&#39;)\\n                        .insert({ username: req.body.username, password: hash })\\n                        .returning(&#39;*&#39;);\\n\\n        res.json({ success: true, token: encode(user[0])});\\n    } catch (err) {\\n        res.status(500).json({ success: false, errorMessage: err });\\n    }\\n});\\n\\nrouter.post(&#39;/login&#39;, async (req, res) =&gt; {\\n    try {\\n        const credentials = {\\n            username: req.body.username,\\n            password: req.body.password\\n        };\\n\\n        const user = await knex(&#39;users&#39;).where({ username: credentials.username }).first();\\n        if (!user || !bcrypt.compareSync(credentials.password, user.password)) {\\n            throw new Error(&#39;Incorrect password&#39;);\\n        }\\n\\n        res.json({ success: true, token: encode(user) });\\n    } catch (err) {\\n        res.status(500).json({ status: &#39;error&#39;, message: err });\\n    }\\n});\\n\\nrouter.get(&#39;/user&#39;, isAuthenticated, (req, res) =&gt; {\\n    res.json({\\n        status: &#39;success&#39;,\\n        user: req.user\\n    })\\n});\\n\\nfunction encode(user) {\\n    const token = {\\n        exp: moment().add(7, &#39;days&#39;).unix(),\\n        iat: moment().unix(),\\n        sub: user.id\\n    };\\n\\n    return jwt.encode(token, process.env.TOKEN_SECRET);\\n}\\n\\nfunction decode(token, callback) {\\n    const decodedJwt = jwt.decode(token, process.env.TOKEN_SECRET);\\n    const now = moment().unix();\\n\\n    if (now &gt; decodedJwt.exp) {\\n        callback(&#39;Token has expired.&#39;);\\n    } else {\\n        callback(null, decodedJwt);\\n    }\\n}\\n\\nfunction isAuthenticated(req, res, next) {\\n    if (!(req.headers &amp;&amp; req.headers.authorization)) {\\n        return res.status(401).json({ errorMessage: &#39;Unauthorized&#39;} );\\n    }\\n\\n    const token = req.headers.authorization;\\n    decode(token, async (err, payload) =&gt; {\\n        try {\\n            if (err) {\\n                return res.status(401).json({ errorMessage: &#39;Token expired&#39;} );\\n            }\\n\\n            const user = await knex(&#39;users&#39;).where({ id: parseInt(payload.sub, 10) }).first()\\n            req.user = user.id;\\n            return next();\\n        } catch (err) {\\n            res.status(500).json({ errorMessage: err });\\n        }\\n    })\\n}\\n\\nmodule.exports = router;</code></pre>\\n      </div>\",\"frontmatter\":{\"title\":\"Building an Image Upload App with Angular 4, NodeJS, PostgreSQL, and Amazon S3 – Part 2\",\"date\":\"June 30, 2017\"}}},\"pathContext\":{\"slug\":\"/20170630-image-upload-app-part2/\",\"previous\":{\"fields\":{\"slug\":\"/20170630-image-upload-app-part1/\"},\"frontmatter\":{\"title\":\"Building an Image Upload App with Angular 4, NodeJS, PostgreSQL, and Amazon S3 - Part 1\"}},\"next\":{\"fields\":{\"slug\":\"/20180409-javascripts-call-bind-and-apply-a-quick-explanation/\"},\"frontmatter\":{\"title\":\"JavaScript's call, bind, and apply - A Quick Explanation\"}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---20170630-image-upload-app-part-2-5f5ac7bb4434720b3059.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Matthew Brown's JS Blog\",\"author\":\"Matthew Brown\"}},\"markdownRemark\":{\"id\":\"/home/travis/build/mbrown333/mbrown333.github.io/src/pages/20170630-image-upload-app-part2/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>Building a Node/Express User service with JWT authentication</h2>\\n<p>In <a href=\\\"/20170630-image-upload-app-part1\\\">Part 1</a> we laid the groundwork for building our web services by setting up Docker containers. </p>\\n<p>Part 2 consist of defining and creating a user table in our PostgreSQL data store and then building a user service that other services and our user interface can talk to. We’ll be using an ORM called knex to handle our database queries. </p>\\n<p><strong>Requirements</strong></p>\\n<ul>\\n<li>Users should be able to register and login</li>\\n<li>We will be using JWT based security to secure our application and the service will be responsible for generating the tokens based on user credentials.</li>\\n<li>Our images service will also communicate with the user service to validate that a user is signed in. If we were creating other services they could also make use of the user service.</li>\\n</ul>\\n<p>In order to follow along with building the service in this article you’ll need to have completed Part 1 or clone the git repository and checkout the Part 2 tag in addition to having Docker installed and running locally: </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">git clone https://github.com/mbrown333/angular4-node-image-upload-app.git \\ncd angular4-node-image-upload-app \\ngit checkout tag/Part2 \\ndocker-compose up</code></pre>\\n      </div>\\n<h2>Database Table Setup</h2>\\n<p>One more thing we’ll need is the knex cli for creating migrations. Use the command <code class=\\\"language-text\\\">npm i -g knex-cli</code> to install. </p>\\n<p>Next step will be to add a knexfile to configure the ORM that we’ll be using to build out our service: </p>\\n<p><em>/users-api/knexfile.js</em> </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">const path = require(&#39;path&#39;); \\n\\nmodule.exports = { \\n  development: { \\n    client: &#39;pg&#39;, \\n    connection: process.env.DATABASE_URL, \\n    migrations: { \\n      directory: path.join(__dirname, &#39;db&#39;, &#39;migrations&#39;) \\n    } \\n  } \\n}</code></pre>\\n      </div>\\n<p>Here we’ve created a config object for our development object. We’re using the ‘pg’ client which is for PostgreSQL. Knex can connect to other types of databases and if you take a look in our package.json file you’ll notice that the pg package is included in the dependencies. </p>\\n<p>For connection we give the environment variable that we specified the database connection string in the docker-compose.yml file. And then finally we specify a directory (/db/migrations) to store migrations in. </p>\\n<p>Now we’re ready to create a migration using the knex-cli. Open up a command prompt in the /users-api folder and enter the following commands: </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">npm install knex knex migrate:make users</code></pre>\\n      </div>\\n<p>This will create a migration file in the /db/migrations folder that has the following structure:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">exports.up = function(knex, Promise) { \\n\\n}; \\n\\nexports.down = function(knex, Promise) { \\n\\n}; </code></pre>\\n      </div>\\n<p>We’ll be putting the changes we want to make in the up function, and a way to reverse those changes in the down function. What we want to accomplish with this migration is to create our user table and define the structure. </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">exports.up = (knex, Promise) =&gt; { \\n  return knex.schema.createTable(&#39;users&#39;, table =&gt; { \\n    table.increments(); \\n    table.timestamp(&#39;createdAt&#39;).notNullable().defaultTo(knex.raw(&#39;now()&#39;)); \\n    table.string(&#39;username&#39;).unique().notNullable(); \\n    table.string(&#39;password&#39;).notNullable(); \\n  }); \\n}; \\n\\nexports.down = function(knex, Promise) { \\n  return knex.schema.dropTable(&#39;users&#39;); \\n};</code></pre>\\n      </div>\\n<p><em>/users-api/db/db.js</em></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">const config = require(&#39;../knexfile.js&#39;); \\nconst knex = require(&#39;knex&#39;)(config[&#39;development&#39;]); \\n\\nmodule.exports = knex; \\n\\nknex.migrate.latest([&#39;development&#39;]);</code></pre>\\n      </div>\\n<p>Pretty straightforward here, we’re just creating a users table to store username and password and an id field. Then in the db.js file we pull our config and knexfile and run the migration we just created. Now that we have our data store defined we’re ready to create our routes. We’ll create a file in the /users-api/routes folder to define our user routes. We’ll be creating three routes to register a user, login a user, and verify a user is authenticated. </p>\\n<p><em>/users-api/routes/users.js</em></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">const express = require(&#39;express&#39;); \\nconst router = express.Router(); \\nconst knex = require(&#39;../db/db&#39;); \\nconst moment = require(&#39;moment&#39;); \\nconst jwt = require(&#39;jwt-simple&#39;); \\nconst bcrypt = require(&#39;bcryptjs&#39;); \\n\\nrouter.post(&#39;/user&#39;, async (req, res) =&gt; { \\n  try { \\n    const salt = bcrypt.genSaltSync(); \\n    const hash = bcrypt.hashSync(req.body.password, salt); \\n    \\n    const user = await knex(&#39;users&#39;) \\n      .insert({ username: req.body.username, password: hash }) \\n      .returning(&#39;*&#39;); \\n      \\n    res.json({ success: true, token: encode(user[0])}); \\n  } catch (err) { \\n    res.status(500).json({ \\n      success: false, \\n      errorMessage: err \\n    }); \\n  } }); \\n  \\n  function encode(user) { \\n    const token = { \\n      exp: moment().add(7, &#39;days&#39;).unix(), \\n      iat: moment().unix(), \\n      sub: user.id \\n    }; \\n    \\n    return jwt.encode(token, process.env.TOKEN_SECRET); \\n  } \\n  \\n  module.exports = router;</code></pre>\\n      </div>\\n<p>This first one is the route for registering a new user. A user will enter a username and password and then use bcrypt to generate a hash and store the hash as a password instead of the plain text version. You’ll see using knex to generate SQL queries is very straightforward. We specify the table ‘users’ and then pass the object to store. </p>\\n<p>Finally the newly created user will be returned so that we can use the jwt-simple module to generate a JWT token to return in the JSON reponse body. Now that users can register they need to have the ability to login. </p>\\n<p><em>/users-api/routes/users.js</em> </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">router.post(&#39;/login&#39;, async (req, res) =&gt; { \\n  try { \\n    const credentials = { \\n      username: req.body.username, \\n      password: req.body.password \\n    }; \\n    \\n    const user = await knex(&#39;users&#39;)\\n      .where({ username: credentials.username })\\n      .first(); \\n      \\n    if (!user || !bcrypt.compareSync(credentials.password, user.password)) { \\n      throw new Error(&#39;Incorrect password&#39;); \\n    } \\n      \\n    res.json({ success: true, token: encode(user) }); \\n  } catch (err) { \\n    res.status(500).json({ status: &#39;error&#39;, message: err }); \\n  } \\n});</code></pre>\\n      </div>\\n<p> We’ll use the username passed in by the user to find a user record in the data store and then let bcrypt test if the entered password matches the hash stored in the database. Then if it does, a token is created and passed back in the response body. </p>\\n<p> <em>/users-api/routes/users.js</em> </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">router.get(&#39;/user&#39;, isAuthenticated, (req, res) =&gt; { \\n  res.json({ status: &#39;success&#39;, user: req.user }) \\n }); \\n  \\n function decode(token, callback) { \\n   const decodedJwt = jwt.decode(token, process.env.TOKEN_SECRET); \\n   const now = moment().unix(); \\n   \\n   if (now &gt; decodedJwt.exp) { \\n     callback(&#39;Token has expired.&#39;); \\n   } else { \\n     callback(null, decodedJwt); \\n   } \\n } \\n \\n function isAuthenticated(req, res, next) { \\n   if (!(req.headers &amp;&amp; req.headers.authorization)) { \\n     return res.status(401).json({ errorMessage: &#39;Unauthorized&#39;} ); \\n   } \\n   \\n   const token = req.headers.authorization; \\n   decode(token, async (err, payload) =&gt; { \\n     try { \\n       if (err) { \\n         return res.status(401).json({ errorMessage: &#39;Token expired&#39;} ); \\n       } \\n       \\n       const user = await knex(&#39;users&#39;).where({ id: parseInt(payload.sub, 10) }).first() \\n       req.user = user.id; \\n       \\n       return next(); \\n     } catch (err) { \\n       res.status(500).json({ errorMessage: err }); \\n     } \\n   }) \\n }</code></pre>\\n      </div>\\n<p>Finally we need a route to verify that a user is logged in and include their id in the response if successful. Using the bcrypt and jwt-simple Node modules to do the heavy lifting you can see that it’s fairly straightforward to create basic JWT authentication for Node services. Putting it all together, here is our final routes file: </p>\\n<p><em>/users-api/routes/users.js</em></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">const express = require(&#39;express&#39;);\\nconst router = express.Router();\\nconst knex = require(&#39;../db/db&#39;);\\nconst moment = require(&#39;moment&#39;);\\nconst jwt = require(&#39;jwt-simple&#39;);\\nconst bcrypt = require(&#39;bcryptjs&#39;);\\n\\nrouter.post(&#39;/user&#39;, async (req, res) =&gt; {\\n    try {\\n        const salt = bcrypt.genSaltSync();\\n        const hash = bcrypt.hashSync(req.body.password, salt);\\n\\n        const user = await knex(&#39;users&#39;)\\n                        .insert({ username: req.body.username, password: hash })\\n                        .returning(&#39;*&#39;);\\n\\n        res.json({ success: true, token: encode(user[0])});\\n    } catch (err) {\\n        res.status(500).json({ success: false, errorMessage: err });\\n    }\\n});\\n\\nrouter.post(&#39;/login&#39;, async (req, res) =&gt; {\\n    try {\\n        const credentials = {\\n            username: req.body.username,\\n            password: req.body.password\\n        };\\n\\n        const user = await knex(&#39;users&#39;).where({ username: credentials.username }).first();\\n        if (!user || !bcrypt.compareSync(credentials.password, user.password)) {\\n            throw new Error(&#39;Incorrect password&#39;);\\n        }\\n\\n        res.json({ success: true, token: encode(user) });\\n    } catch (err) {\\n        res.status(500).json({ status: &#39;error&#39;, message: err });\\n    }\\n});\\n\\nrouter.get(&#39;/user&#39;, isAuthenticated, (req, res) =&gt; {\\n    res.json({\\n        status: &#39;success&#39;,\\n        user: req.user\\n    })\\n});\\n\\nfunction encode(user) {\\n    const token = {\\n        exp: moment().add(7, &#39;days&#39;).unix(),\\n        iat: moment().unix(),\\n        sub: user.id\\n    };\\n\\n    return jwt.encode(token, process.env.TOKEN_SECRET);\\n}\\n\\nfunction decode(token, callback) {\\n    const decodedJwt = jwt.decode(token, process.env.TOKEN_SECRET);\\n    const now = moment().unix();\\n\\n    if (now &gt; decodedJwt.exp) {\\n        callback(&#39;Token has expired.&#39;);\\n    } else {\\n        callback(null, decodedJwt);\\n    }\\n}\\n\\nfunction isAuthenticated(req, res, next) {\\n    if (!(req.headers &amp;&amp; req.headers.authorization)) {\\n        return res.status(401).json({ errorMessage: &#39;Unauthorized&#39;} );\\n    }\\n\\n    const token = req.headers.authorization;\\n    decode(token, async (err, payload) =&gt; {\\n        try {\\n            if (err) {\\n                return res.status(401).json({ errorMessage: &#39;Token expired&#39;} );\\n            }\\n\\n            const user = await knex(&#39;users&#39;).where({ id: parseInt(payload.sub, 10) }).first()\\n            req.user = user.id;\\n            return next();\\n        } catch (err) {\\n            res.status(500).json({ errorMessage: err });\\n        }\\n    })\\n}\\n\\nmodule.exports = router;</code></pre>\\n      </div>\",\"frontmatter\":{\"title\":\"Building an Image Upload App with Angular 4, NodeJS, PostgreSQL, and Amazon S3 – Part 2\",\"date\":\"June 30, 2017\"}}},\"pathContext\":{\"slug\":\"/20170630-image-upload-app-part2/\",\"previous\":{\"fields\":{\"slug\":\"/20170630-image-upload-app-part1/\"},\"frontmatter\":{\"title\":\"Building an Image Upload App with Angular 4, NodeJS, PostgreSQL, and Amazon S3 - Part 1\"}},\"next\":{\"fields\":{\"slug\":\"/20180409-javascripts-call-bind-and-apply-a-quick-explanation/\"},\"frontmatter\":{\"title\":\"JavaScript's call, bind, and apply - A Quick Explanation\"}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/20170630-image-upload-app-part-2.json\n// module id = 515\n// module chunks = 174222985609962"],"sourceRoot":""}